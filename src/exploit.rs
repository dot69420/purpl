use std::path::{Path, PathBuf};
use std::fs;
use colored::*;
use roxmltree::Document;
use serde::Deserialize;
use crate::executor::CommandExecutor;
use crate::io_handler::IoHandler;

#[derive(Deserialize, Debug)]
pub struct SearchResult {
    #[serde(rename = "RESULTS_EXPLOIT")]
    pub results: Vec<ExploitItem>,
}

#[derive(Deserialize, Debug)]
pub struct ExploitItem {
    #[serde(rename = "Title")]
    pub title: String,
    #[serde(rename = "Path")]
    pub path: String,
    // Type is often useful to distinguish local/remote
    #[serde(rename = "Type")]
    pub kind: Option<String>,
}

pub struct Service {
    pub product: String,
    pub version: String,
    pub port: String,
}

pub fn run_exploit_search(target_input: &str, _use_proxy: bool, executor: &dyn CommandExecutor, io: &dyn IoHandler) {
    // 1. Check Dependency
    if executor.execute_output("searchsploit", &["--version"]).is_err() {
        io.println(&format!("{}", "[-] 'searchsploit' not found. Please install it (sudo pacman -S exploitdb).".red()));
        return;
    }

    // 2. Resolve Nmap XML Path
    // Input can be "192.168.1.1" (look in history) or "scans/..." (direct path)
    let xml_path = resolve_xml_path(target_input);
    if xml_path.is_none() {
        io.println(&format!("{}", format!("[!] Could not find Nmap XML report for '{}'.", target_input).red()));
        io.println("    Provide a direct .xml file path or a target IP from a previous scan.");
        return;
    }
    let xml_path = xml_path.unwrap();
    io.println(&format!("{}", format!("[+] Parsing report: {}", xml_path.display()).blue()));

    // 3. Extract Services
    let services = extract_services(&xml_path);
    if services.is_empty() {
        io.println(&format!("{}", "[-] No services with version information found in report.".yellow()));
        return;
    }

    io.println(&format!("{}", format!("[+] Found {} services with versions. Searching Exploit-DB...", services.len()).green()));
    io.println(&format!("{}", "    Note: Results are heuristic. Always verify target applicability.".dimmed()));

    // 4. Query Searchsploit
    for svc in services {
        // Construct query: "Product Version"
        // Sometimes version is empty, that's fine, we search product.
        let query_term = format!("{} {}", svc.product, svc.version);
        let query_term = query_term.trim();
        
        if query_term.len() < 3 { continue; } // Skip junk

        io.println(&format!("\n{}: {} ({})", "Querying".blue().bold(), query_term.cyan(), svc.port));
        
        let (cmd_bin, cmd_args) = build_searchsploit_command("searchsploit", &svc.product, &svc.version);
        let cmd_args_str: Vec<&str> = cmd_args.iter().map(|s| s.as_str()).collect();

        match executor.execute_output(&cmd_bin, &cmd_args_str) {
            Ok(out) => {
                if !out.status.success() {
                    io.println(&format!("  {}", "[-] Search failed.".red()));
                    continue;
                }
                
                let json_str = String::from_utf8_lossy(&out.stdout);
                
                // Parse JSON
                // Searchsploit returns a JSON object with key "RESULTS_EXPLOIT"
                match serde_json::from_str::<SearchResult>(&json_str) {
                    Ok(res) => {
                        if res.results.is_empty() {
                            io.println(&format!("  {}", "No exploits found.".dimmed()));
                        } else {
                            // Limit to top 5 to avoid spam
                            for exploit in res.results.iter().take(5) {
                                let kind = exploit.kind.as_deref().unwrap_or("?");
                                io.println(&format!("  [{}]. {} | {}", kind.green(), exploit.title, exploit.path.dimmed()));
                            }
                            if res.results.len() > 5 {
                                io.println(&format!("  ... and {} more.", res.results.len() - 5));
                            }
                        }
                    },
                    Err(_) => {
                        // Sometimes searchsploit returns just "[]" or empty if nothing found, 
                        // but sometimes structure differs if errors.
                        // Assuming empty if parse fails or valid empty array.
                        io.println(&format!("  {}", "No exploits found (or parsing error).".dimmed()));
                    }
                }
            },
            Err(e) => io.println(&format!("  {} {}", "[!] Failed to execute searchsploit:".red(), e)),
        }
    }
}

pub fn resolve_xml_path(input: &str) -> Option<PathBuf> {
    let path = Path::new(input);
    
    // Case A: Direct file path provided
    if path.is_file() && input.ends_with(".xml") {
        return Some(path.to_path_buf());
    }

    // Case B: Target IP/Name provided -> Search scans/
    // We sanitize input same as nmap module does (replace / with _)
    let safe_target = input.replace('/', "_");
    let scans_dir = Path::new("scans").join(&safe_target);

    if scans_dir.exists() && scans_dir.is_dir() {
        // Find latest timestamped directory
        if let Ok(entries) = fs::read_dir(scans_dir) {
            let mut dirs: Vec<_> = entries.flatten() 
                .filter(|e| e.path().is_dir())
                .collect();
            
            // Sort by filename (YYYYMMDD format sorts naturally)
            dirs.sort_by_key(|e| e.file_name());
            
            // Iterate backwards (newest first) to find one with an XML
            for dir_entry in dirs.iter().rev() {
                if let Ok(files) = fs::read_dir(dir_entry.path()) {
                    for f in files.flatten() {
                        if f.path().extension().map_or(false, |e| e == "xml") {
                            return Some(f.path());
                        }
                    }
                }
            }
        }
    }
    None
}

pub fn extract_services(path: &Path) -> Vec<Service> {
    let content = match fs::read_to_string(path) {
        Ok(c) => c,
        Err(_) => return Vec::new(),
    };
    extract_services_from_content(&content)
}

pub fn extract_services_from_content(content: &str) -> Vec<Service> {
    let doc = match Document::parse(content) {
        Ok(d) => d,
        Err(_) => return Vec::new(),
    };

    let mut list = Vec::new();

    for port in doc.descendants().filter(|n| n.has_tag_name("port")) {
         if let Some(service) = port.children().find(|n| n.has_tag_name("service")) {
             let product = service.attribute("product").unwrap_or("").to_string();
             let version = service.attribute("version").unwrap_or("").to_string();
             let port_id = port.attribute("portid").unwrap_or("?").to_string();

             if !product.is_empty() { 
                 list.push(Service { product, version, port: port_id });
             }
         }
    }
    list
}

pub fn build_searchsploit_command(
    base_cmd: &str,
    product: &str,
    version: &str
) -> (String, Vec<String>) {
    let mut args = vec!["--json".to_string(), product.to_string()];
    if !version.is_empty() {
        args.push(version.to_string());
    }
    (base_cmd.to_string(), args)
}

#[cfg(test)]
#[path = "exploit_tests.rs"]
mod tests;
