use std::process::Command;
use std::path::{Path, PathBuf};
use std::fs;
use colored::*;
use roxmltree::Document;
use serde::Deserialize;

#[derive(Deserialize, Debug)]
struct SearchResult {
    #[serde(rename = "RESULTS_EXPLOIT")]
    results: Vec<ExploitItem>,
}

#[derive(Deserialize, Debug)]
struct ExploitItem {
    #[serde(rename = "Title")]
    title: String,
    #[serde(rename = "Path")]
    path: String,
    // Type is often useful to distinguish local/remote
    #[serde(rename = "Type")]
    kind: Option<String>,
}

struct Service {
    product: String,
    version: String,
    port: String,
}

pub fn run_exploit_search(target_input: &str, _use_proxy: bool) {
    // 1. Check Dependency
    if Command::new("searchsploit").arg("--version").output().is_err() {
        println!("{}", "[-] 'searchsploit' not found. Please install it (sudo apt install exploitdb).".red());
        return;
    }

    // 2. Resolve Nmap XML Path
    // Input can be "192.168.1.1" (look in history) or "scans/..." (direct path)
    let xml_path = resolve_xml_path(target_input);
    if xml_path.is_none() {
        println!("{}", format!("[!] Could not find Nmap XML report for '{}'.", target_input).red());
        println!("    Provide a direct .xml file path or a target IP from a previous scan.");
        return;
    }
    let xml_path = xml_path.unwrap();
    println!("{}", format!("[+] Parsing report: {}", xml_path.display()).blue());

    // 3. Extract Services
    let services = extract_services(&xml_path);
    if services.is_empty() {
        println!("{}", "[-] No services with version information found in report.".yellow());
        return;
    }

    println!("{}", format!("[+] Found {} services with versions. Searching Exploit-DB...", services.len()).green());
    println!("{}", "    Note: Results are heuristic. Always verify target applicability.".dimmed());

    // 4. Query Searchsploit
    for svc in services {
        // Construct query: "Product Version"
        // Sometimes version is empty, that's fine, we search product.
        let query_term = format!("{} {}", svc.product, svc.version);
        let query_term = query_term.trim();
        
        if query_term.len() < 3 { continue; } // Skip junk

        println!("\n{}: {} ({})", "Querying".blue().bold(), query_term.cyan(), svc.port);
        
        // We pass product and version as separate args so searchsploit ANDs them (usually)
        let mut cmd = Command::new("searchsploit");
        cmd.arg("--json"); // JSON Output
        cmd.arg(&svc.product);
        if !svc.version.is_empty() {
            cmd.arg(&svc.version);
        }

        match cmd.output() {
            Ok(out) => {
                if !out.status.success() {
                    println!("  {}", "[-] Search failed.".red());
                    continue;
                }
                
                let json_str = String::from_utf8_lossy(&out.stdout);
                
                // Parse JSON
                // Searchsploit returns a JSON object with key "RESULTS_EXPLOIT"
                match serde_json::from_str::<SearchResult>(&json_str) {
                    Ok(res) => {
                        if res.results.is_empty() {
                            println!("  {}", "No exploits found.".dimmed());
                        } else {
                            // Limit to top 5 to avoid spam
                            for exploit in res.results.iter().take(5) {
                                let kind = exploit.kind.as_deref().unwrap_or("?");
                                println!("  [{}]. {} | {}", kind.green(), exploit.title, exploit.path.dimmed());
                            }
                            if res.results.len() > 5 {
                                println!("  ... and {} more.", res.results.len() - 5);
                            }
                        }
                    },
                    Err(_) => {
                        // Sometimes searchsploit returns just "[]" or empty if nothing found, 
                        // but sometimes structure differs if errors.
                        // Assuming empty if parse fails or valid empty array.
                        println!("  {}", "No exploits found (or parsing error).".dimmed());
                    }
                }
            },
            Err(e) => println!("  {} {}", "[!] Failed to execute searchsploit:".red(), e),
        }
    }
}

fn resolve_xml_path(input: &str) -> Option<PathBuf> {
    let path = Path::new(input);
    
    // Case A: Direct file path provided
    if path.is_file() && input.ends_with(".xml") {
        return Some(path.to_path_buf());
    }

    // Case B: Target IP/Name provided -> Search scans/
    // We sanitize input same as nmap module does (replace / with _)
    let safe_target = input.replace('/', "_");
    let scans_dir = Path::new("scans").join(&safe_target);

    if scans_dir.exists() && scans_dir.is_dir() {
        // Find latest timestamped directory
        if let Ok(entries) = fs::read_dir(scans_dir) {
            let mut dirs: Vec<_> = entries.flatten() 
                .filter(|e| e.path().is_dir())
                .collect();
            
            // Sort by filename (YYYYMMDD format sorts naturally)
            dirs.sort_by_key(|e| e.file_name());
            
            // Iterate backwards (newest first) to find one with an XML
            for dir_entry in dirs.iter().rev() {
                if let Ok(files) = fs::read_dir(dir_entry.path()) {
                    for f in files.flatten() {
                        if f.path().extension().map_or(false, |e| e == "xml") {
                            return Some(f.path());
                        }
                    }
                }
            }
        }
    }
    None
}

fn extract_services(path: &Path) -> Vec<Service> {
    let content = match fs::read_to_string(path) {
        Ok(c) => c,
        Err(_) => return Vec::new(),
    };

    let doc = match Document::parse(&content) {
        Ok(d) => d,
        Err(_) => return Vec::new(),
    };

    let mut list = Vec::new();

    for port in doc.descendants().filter(|n| n.has_tag_name("port")) {
         if let Some(service) = port.children().find(|n| n.has_tag_name("service")) {
             let product = service.attribute("product").unwrap_or("").to_string();
             let version = service.attribute("version").unwrap_or("").to_string();
             let port_id = port.attribute("portid").unwrap_or("?").to_string();

             if !product.is_empty() { 
                 list.push(Service { product, version, port: port_id });
             }
         }
    }
    list
}
