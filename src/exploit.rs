use chrono::Local;
use colored::*;
use std::fs;
use std::path::Path;

use crate::brute::{self, BruteConfig};
use crate::executor::CommandExecutor;
use crate::history::{HistoryEntry, append_history};
use crate::io_handler::IoHandler;
use crate::nmap;
use crate::ui;

#[derive(Debug, Clone)]
pub enum ExploitToolConfig {
    SqlMap {
        target: String,
        extra_args: Option<String>,
    },
    Curl {
        _target: String,
        args: Vec<String>,
    },
    Hydra(BruteConfig),
}

#[derive(Debug, Clone)]
pub struct ExploitConfig {
    pub tool_config: ExploitToolConfig,
}

pub fn configure_exploitation(
    target_input: &str,
    tool_name: Option<&str>,
    extra_args: Option<&str>,
    executor: &dyn CommandExecutor,
    io: &dyn IoHandler,
) -> Option<ExploitConfig> {
    io.println(&format!(
        "\n{}",
        "--- Active Exploitation Module ---".red().bold()
    ));

    let final_target = if target_input.is_empty() {
        if let Some(t) = select_target_or_scan(false, executor, io) {
            // Assuming false for proxy during config scan
            io.println(&format!(
                "{} {}",
                "[*] Target set to:".blue(),
                t.yellow().bold()
            ));
            t
        } else {
            return None;
        }
    } else {
        target_input.to_string()
    };

    // Step 2: Tool Selection
    let tool = if let Some(t) = tool_name {
        t.to_string()
    } else {
        io.println("\nSelect Exploitation Tool:");
        io.println("[1] SQLMap (SQL Injection)");
        io.println("[2] Curl (Sophisticated Request Builder)");
        io.println("[3] Hydra (Credential Access)");
        io.println("[0] Back");

        let input = ui::get_input_styled(io, "Select tool");
        let choice = input.trim().parse::<usize>().unwrap_or(99);

        match choice {
            1 => "sqlmap".to_string(),
            2 => "curl".to_string(),
            3 => "hydra".to_string(),
            0 => return None,
            _ => {
                io.println(&format!("{}", "[!] Invalid selection.".red()));
                std::thread::sleep(std::time::Duration::from_secs(2));
                return None;
            }
        }
    };

    match tool.as_str() {
        "sqlmap" => Some(ExploitConfig {
            tool_config: ExploitToolConfig::SqlMap {
                target: final_target,
                extra_args: extra_args.map(|s| s.to_string()),
            },
        }),
        "curl" => {
            let args = configure_curl(&final_target, extra_args, io);
            if args.is_empty() {
                return None;
            }
            Some(ExploitConfig {
                tool_config: ExploitToolConfig::Curl {
                    _target: final_target,
                    args,
                },
            })
        }
        "hydra" => {
            if let Some(brute_config) =
                brute::configure_brute_force(&final_target, false, executor, io)
            {
                Some(ExploitConfig {
                    tool_config: ExploitToolConfig::Hydra(brute_config),
                })
            } else {
                None
            }
        }
        _ => {
            io.println(&format!("{}", format!("[!] Unknown tool '{}'", tool).red()));
            None
        }
    }
}

fn configure_curl(target: &str, extra_args: Option<&str>, io: &dyn IoHandler) -> Vec<String> {
    let mut method = "GET".to_string();
    let mut headers: Vec<String> = Vec::new();
    let mut body: Option<String> = None;
    let mut cookies: Option<String> = None;
    let mut verbose = false;
    let mut follow_redirects = true;

    // Pre-populate if extra_args exist?
    // Parsing raw curl args is hard. We'll assume extra_args are appended at the end if provided via CLI,
    // but here we are building interactively.

    loop {
        // io.clear_screen(); // Assuming clear_screen is not available on io trait directly, using printlns
        io.println("\n");
        io.println(&format!("{}", "=== CURL REQUEST BUILDER ===".cyan().bold()));
        io.println(&format!("Target: {}", target.yellow()));
        io.println(&"-".repeat(40));

        io.println(&format!("1. Method:    {}", method.green().bold()));
        io.println(&format!(
            "2. Headers:   {}",
            if headers.is_empty() {
                "None".dimmed()
            } else {
                format!("{} set", headers.len()).cyan()
            }
        ));
        io.println(&format!(
            "3. Body:      {}",
            if let Some(b) = &body {
                if b.len() > 20 {
                    format!("{}...", &b[..17])
                } else {
                    b.clone()
                }
                .cyan()
            } else {
                "None".dimmed()
            }
        ));
        io.println(&format!(
            "4. Cookies:   {}",
            if let Some(c) = &cookies {
                c.cyan()
            } else {
                "None".dimmed()
            }
        ));
        io.println(&format!(
            "5. Options:   Redirects [{}], Verbose [{}]",
            if follow_redirects {
                "ON".green()
            } else {
                "OFF".red()
            },
            if verbose { "ON".green() } else { "OFF".red() }
        ));
        io.println(&"-".repeat(40));
        io.println("[P] Preview Command");
        io.println("[E] EXECUTE");
        io.println("[0] Cancel");

        io.print("\nSelect option: ");
        io.flush();
        let input = io.read_line().trim().to_uppercase();

        match input.as_str() {
            "1" => {
                let m = ui::get_input_styled(io, "Enter HTTP Method (GET, POST, PUT, DELETE, etc)");
                if !m.is_empty() {
                    method = m.to_uppercase();
                }
            }
            "2" => {
                io.println("\n--- Manage Headers ---");
                for (i, h) in headers.iter().enumerate() {
                    io.println(&format!("[{}] {}", i + 1, h));
                }
                io.println("[A] Add Header");
                io.println("[C] Clear All");
                io.println("[0] Back");
                let choice = ui::get_input_styled(io, "Choice");
                match choice.as_str().to_uppercase().as_str() {
                    "A" => {
                        let h = ui::get_input_styled(
                            io,
                            "Enter Header (e.g. 'Content-Type: application/json')",
                        );
                        if !h.is_empty() {
                            headers.push(h);
                        }
                    }
                    "C" => headers.clear(),
                    _ => {}
                }
            }
            "3" => {
                let b = ui::get_input_styled(io, "Enter Request Body");
                if b.is_empty() {
                    body = None;
                } else {
                    body = Some(b);
                }
            }
            "4" => {
                let c = ui::get_input_styled(io, "Enter Cookies (key=value; key2=value2)");
                if c.is_empty() {
                    cookies = None;
                } else {
                    cookies = Some(c);
                }
            }
            "5" => {
                io.println("\n[1] Toggle Redirects");
                io.println("[2] Toggle Verbose");
                let choice = ui::get_input_styled(io, "Choice");
                match choice.as_str() {
                    "1" => follow_redirects = !follow_redirects,
                    "2" => verbose = !verbose,
                    _ => {}
                }
            }
            "P" => {
                // Preview
                let mut p_args = Vec::new();
                p_args.push("-X");
                p_args.push(&method);
                for h in &headers {
                    p_args.push("-H");
                    p_args.push(h);
                }
                if let Some(c) = &cookies {
                    p_args.push("-b");
                    p_args.push(c);
                }
                if let Some(b) = &body {
                    p_args.push("-d");
                    p_args.push(b);
                }
                if follow_redirects {
                    p_args.push("-L");
                }
                if verbose {
                    p_args.push("-v");
                }
                p_args.push(target);
                io.println(&format!(
                    "\n{} curl {}",
                    "[PREVIEW]".blue(),
                    p_args.join(" ")
                ));
                io.print("\nPress Enter...");
                io.flush();
                let _ = io.read_line();
            }
            "E" => {
                break;
            }
            "0" => {
                // How to cancel? We need to return valid args or empty?
                // If we return empty, execute_curl might fail or do nothing?
                // But execute_curl expects args.
                // configure_exploitation returns Option<ExploitConfig>.
                // But configure_curl returns Vec<String>.
                // We should change configure_curl signature to return Option<Vec<String>>.
                // But that requires changing call site.

                // For now, let's return an empty vector and handle it?
                // Or panic? No.
                // Let's update call site first?
                // Wait, I can't update call site easily in one go.
                // I'll assume for this step I just return defaults (GET target) if cancelled?
                // Or better, I return empty args and let execute check?
                // execute_curl checks args.
                // Let's check execute_curl.
                // It builds cmd_bin "curl". Args are appended.
                // If args is just target, it runs GET.
                // If args empty? `args.last()` unwraps target.

                // So I MUST return at least target.
                // I will return default GET target if cancelled?
                // Ideally I should return None.

                // I will update the signature in the SAME replacement.
                return Vec::new(); // Changed return type to handle this? No, I need to update signature.
            }
            _ => {}
        }
    }

    // Build Final Args
    let mut args = Vec::new();
    args.push("-X".to_string());
    args.push(method);

    for h in headers {
        args.push("-H".to_string());
        args.push(h);
    }

    if let Some(c) = cookies {
        args.push("-b".to_string());
        args.push(c);
    }

    if let Some(b) = body {
        args.push("-d".to_string());
        args.push(b);
    }

    if follow_redirects {
        args.push("-L".to_string());
    }
    args.push("-k".to_string()); // Always insecure for pentest
    args.push("-g".to_string()); // Globbing off

    if verbose {
        args.push("-v".to_string());
    } else {
        args.push("-s".to_string()); // Silent by default if not verbose
    }

    if let Some(extras) = extra_args {
        for arg in extras.split_whitespace() {
            args.push(arg.to_string());
        }
    }

    args.push(target.to_string());
    args
}

pub fn execute_exploitation(
    config: ExploitConfig,
    use_proxy: bool,
    executor: &dyn CommandExecutor,
    io: &dyn IoHandler,
) {
    match config.tool_config {
        ExploitToolConfig::SqlMap { target, extra_args } => {
            run_sqlmap(&target, extra_args.as_deref(), use_proxy, executor, io);
        }
        ExploitToolConfig::Curl { _target: _, args } => {
            // target is inside args already
            execute_curl(args, use_proxy, executor, io);
        }
        ExploitToolConfig::Hydra(brute_config) => {
            brute::execute_brute_force(brute_config, use_proxy, executor, io);
        }
    }
}

// Deprecated wrapper
pub fn run_exploitation_tool(
    target_input: &str,
    tool_name: Option<&str>,
    extra_args: Option<&str>,
    use_proxy: bool,
    executor: &dyn CommandExecutor,
    io: &dyn IoHandler,
) {
    if let Some(config) = configure_exploitation(target_input, tool_name, extra_args, executor, io)
    {
        execute_exploitation(config, use_proxy, executor, io);
    }
}

fn select_target_or_scan(
    use_proxy: bool,
    executor: &dyn CommandExecutor,
    io: &dyn IoHandler,
) -> Option<String> {
    let nmap_dir = Path::new("scans").join("nmap");
    let mut targets: Vec<String> = Vec::new();

    if nmap_dir.exists() {
        if let Ok(entries) = fs::read_dir(nmap_dir) {
            for entry in entries.flatten() {
                if let Ok(ft) = entry.file_type() {
                    if ft.is_dir() {
                        if let Ok(name) = entry.file_name().into_string() {
                            targets.push(name);
                        }
                    }
                }
            }
        }
    }
    targets.sort();

    io.println(&format!("\n{}", "Target Selection:".cyan().bold()));
    if targets.is_empty() {
        io.println(&format!("{}", "  (No previous Nmap scans found)".dimmed()));
    } else {
        for (i, t) in targets.iter().enumerate() {
            io.println(&format!("[{}] {}", i + 1, t));
        }
    }

    let scan_option_idx = targets.len() + 1;
    let manual_option_idx = targets.len() + 2;

    io.println(&format!(
        "[{}] {}",
        scan_option_idx,
        "New Target (Run Nmap Scan first)".green()
    ));
    io.println(&format!(
        "[{}] {}",
        manual_option_idx,
        "New Target (Manual Input)".yellow()
    ));
    io.println("[0] Back");

    io.print("\nSelect option: ");
    io.flush();
    let input = io.read_line();
    let choice = input.trim().parse::<usize>().unwrap_or(999);

    if choice == 0 {
        return None;
    }

    if choice > 0 && choice <= targets.len() {
        return Some(targets[choice - 1].clone());
    } else if choice == scan_option_idx {
        let new_target = ui::get_input_styled(io, "Enter Target IP for Scan");
        if new_target.is_empty() {
            return None;
        }

        io.println(&format!(
            "{}",
            "\n[+] Redirecting to Network Scan module...".blue()
        ));
        nmap::run_nmap_scan(&new_target, None, false, None, use_proxy, executor, io);
        return Some(new_target);
    } else if choice == manual_option_idx {
        let manual = ui::get_input_styled(io, "Enter Target IP");
        if manual.is_empty() {
            return None;
        }
        return Some(manual);
    }

    io.println(&format!("{}", "[!] Invalid selection.".red()));
    std::thread::sleep(std::time::Duration::from_secs(2));
    None
}

pub fn run_sqlmap(
    target: &str,
    extra_args: Option<&str>,
    use_proxy: bool,
    executor: &dyn CommandExecutor,
    io: &dyn IoHandler,
) {
    if executor.execute_output("sqlmap", &["--version"]).is_err() {
        io.println(&format!(
            "{}",
            "[-] 'sqlmap' not found. Please install it.".red()
        ));
        return;
    }

    let safe_target = target
        .replace("://", "_")
        .replace('/', "_")
        .replace('?', "_");
    let date = Local::now().format("%Y%m%d_%H%M%S").to_string();
    let output_dir = format!("scans/exploit/sqlmap/{}/{}", safe_target, date);
    fs::create_dir_all(&output_dir).expect("Failed to create output dir");

    io.println(&format!(
        "{}",
        format!("\n[+] Starting SQLMap on {}", target).green()
    ));
    io.println(&format!("[+] Output directory: {}", output_dir));

    let mut args = vec![
        "-u".to_string(),
        target.to_string(),
        "--batch".to_string(),
        "--output-dir".to_string(),
        output_dir.clone(),
    ];

    if let Some(extras) = extra_args {
        for arg in extras.split_whitespace() {
            args.push(arg.to_string());
        }
    }

    let mut cmd_bin = "sqlmap".to_string();
    if use_proxy {
        args.insert(0, cmd_bin);
        cmd_bin = "proxychains".to_string();
    }

    let args_str: Vec<&str> = args.iter().map(|s| s.as_str()).collect();
    io.println(&format!("Executing: {} {}", cmd_bin, args_str.join(" ")));

    match executor.execute(&cmd_bin, &args_str) {
        Ok(s) => {
            if s.success() {
                io.println(&format!("{}", "\n[+] SQLMap finished.".green()));
                let _ = append_history(&HistoryEntry::new("Exploit-SQLMap", target, "Finished"));
            } else {
                io.println(&format!("{}", "\n[!] SQLMap failed or stopped.".yellow()));
            }
        }
        Err(e) => io.println(&format!("{} {}", "[!] Failed to run sqlmap:".red(), e)),
    }
}

pub fn execute_curl(
    mut args: Vec<String>,
    use_proxy: bool,
    executor: &dyn CommandExecutor,
    io: &dyn IoHandler,
) {
    let mut cmd_bin = "curl".to_string();
    if use_proxy {
        args.insert(0, cmd_bin);
        cmd_bin = "proxychains".to_string();
    }

    // Setup Output
    // Extract target from args if possible or use generic name
    let target = args
        .last()
        .cloned()
        .unwrap_or_else(|| "unknown".to_string());
    let safe_target = target.replace("://", "_").replace('/', "_");
    let date = Local::now().format("%Y%m%d_%H%M%S").to_string();
    let output_dir = format!("scans/exploit/curl/{}/{}", safe_target, date);
    fs::create_dir_all(&output_dir).expect("Failed to create output dir");
    let output_file = format!("{}/response.txt", output_dir);

    // Using execute_output to capture stdout/stderr
    let args_str: Vec<&str> = args.iter().map(|s| s.as_str()).collect();
    io.println(&format!(
        "\n{} Executing: {} {}\n",
        "[*]".blue().bold(),
        cmd_bin,
        args_str.join(" ")
    ));
    io.println(&format!("[+] Saving output to: {}", output_file));

    match executor.execute_output(&cmd_bin, &args_str) {
        Ok(output) => {
            // Write to file
            let stdout = String::from_utf8_lossy(&output.stdout);
            let stderr = String::from_utf8_lossy(&output.stderr);

            let mut full_log = String::new();
            full_log.push_str("--- STDERR ---\n");
            full_log.push_str(&stderr);
            full_log.push_str("\n--- STDOUT ---\n");
            full_log.push_str(&stdout);

            fs::write(&output_file, full_log).expect("Failed to write curl output");

            // Print to IO (Capture/Screen)
            if output.status.success() {
                io.println(&stdout);
                io.println(&format!("{}", "\n[+] Curl executed successfully.".green()));
            } else {
                io.println(&stderr);
                io.println(&format!(
                    "{}",
                    "[!] Curl returned non-zero exit code.".yellow()
                ));
            }
        }
        Err(e) => io.println(&format!("{} {}", "[!] Failed to execute curl:".red(), e)),
    }
}
