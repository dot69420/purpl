use std::fs;
use std::path::Path;
use colored::*;
use crate::executor::CommandExecutor;
use crate::io_handler::IoHandler;
use crate::history::{append_history, HistoryEntry};
use crate::nmap;
use crate::brute;

pub fn run_exploitation_tool(target_input: &str, tool_name: Option<&str>, extra_args: Option<&str>, use_proxy: bool, executor: &dyn CommandExecutor, io: &dyn IoHandler) {
    io.println(&format!("\n{}", "--- Active Exploitation Module ---".red().bold()));

    let final_target = if target_input.is_empty() {
        if let Some(t) = select_target_or_scan(use_proxy, executor, io) {
            io.println(&format!("{} {}", "[*] Target set to:".blue(), t.yellow().bold()));
            t
        } else {
            return;
        }
    } else {
        target_input.to_string()
    };

    // Step 2: Tool Selection
    let tool = if let Some(t) = tool_name {
        t.to_string()
    } else {
        io.println("\nSelect Exploitation Tool:");
        io.println("[1] SQLMap (SQL Injection)");
        io.println("[2] Curl (Sophisticated Request Builder)");
        io.println("[3] Hydra (Credential Access)");
        io.println("[0] Back");

        io.print("\nSelect tool: ");
        io.flush();
        let input = io.read_line();
        let choice = input.trim().parse::<usize>().unwrap_or(99);

        match choice {
            1 => "sqlmap".to_string(),
            2 => "curl".to_string(),
            3 => "hydra".to_string(),
            0 => return,
            _ => {
                io.println(&format!("{}", "[!] Invalid selection.".red()));
                return;
            }
        }
    };

    match tool.as_str() {
        "sqlmap" => run_sqlmap(&final_target, extra_args, use_proxy, executor, io),
        "curl" => run_curl_exploit(&final_target, extra_args, use_proxy, executor, io),
        "hydra" => brute::run_brute_force(&final_target, use_proxy, executor, io),
        _ => io.println(&format!("{}", format!("[!] Unknown tool '{}'", tool).red()))
    }
}

fn select_target_or_scan(use_proxy: bool, executor: &dyn CommandExecutor, io: &dyn IoHandler) -> Option<String> {
    let nmap_dir = Path::new("scans").join("nmap");
    let mut targets: Vec<String> = Vec::new();

    if nmap_dir.exists() {
        if let Ok(entries) = fs::read_dir(nmap_dir) {
            for entry in entries.flatten() {
                if let Ok(ft) = entry.file_type() {
                    if ft.is_dir() {
                        if let Ok(name) = entry.file_name().into_string() {
                             targets.push(name);
                        }
                    }
                }
            }
        }
    }
    targets.sort();

    io.println(&format!("\n{}", "Target Selection:".cyan().bold()));
    if targets.is_empty() {
        io.println(&format!("{}", "  (No previous Nmap scans found)".dimmed()));
    } else {
        for (i, t) in targets.iter().enumerate() {
            io.println(&format!("[{}] {}", i + 1, t));
        }
    }

    let scan_option_idx = targets.len() + 1;
    let manual_option_idx = targets.len() + 2;

    io.println(&format!("[{}] {}", scan_option_idx, "New Target (Run Nmap Scan first)".green()));
    io.println(&format!("[{}] {}", manual_option_idx, "New Target (Manual Input)".yellow()));
    io.println("[0] Back");

    io.print("\nSelect option: ");
    io.flush();
    let input = io.read_line();
    let choice = input.trim().parse::<usize>().unwrap_or(999);

    if choice == 0 { return None; }

    if choice > 0 && choice <= targets.len() {
        return Some(targets[choice - 1].clone());
    } else if choice == scan_option_idx {
        // Redirect to Nmap Scan
        io.print("\nEnter Target IP for Scan: ");
        io.flush();
        let new_target = io.read_line().trim().to_string();
        if new_target.is_empty() { return None; }
        
        io.println(&format!("{}", "\n[+] Redirecting to Network Scan module...".blue()));
        nmap::run_nmap_scan(&new_target, None, false, None, use_proxy, executor, io);
        
        // After scan, assume user wants to exploit this target
        return Some(new_target);
    } else if choice == manual_option_idx {
        io.print("Enter Target IP: ");
        io.flush();
        let manual = io.read_line().trim().to_string();
        if manual.is_empty() { return None; }
        return Some(manual);
    }

    io.println(&format!("{}", "[!] Invalid selection.".red()));
    None
}

pub fn run_sqlmap(target: &str, extra_args: Option<&str>, use_proxy: bool, executor: &dyn CommandExecutor, io: &dyn IoHandler) {
    if executor.execute_output("sqlmap", &["--version"]).is_err() {
        io.println(&format!("{}", "[-] 'sqlmap' not found. Please install it.".red()));
        return;
    }

    let safe_target = target.replace("://", "_").replace('/', "_").replace('?', "_");
    let output_dir = format!("scans/exploit/sqlmap/{}", safe_target);
    fs::create_dir_all(&output_dir).expect("Failed to create output dir");

    io.println(&format!("{}", format!("\n[+] Starting SQLMap on {}", target).green()));
    io.println(&format!("[+] Output directory: {}", output_dir));

    let mut args = vec![
        "-u".to_string(), target.to_string(),
        "--batch".to_string(),
        "--output-dir".to_string(), output_dir.clone(),
    ];

    if let Some(extras) = extra_args {
        for arg in extras.split_whitespace() {
            args.push(arg.to_string());
        }
    }

    let mut cmd_bin = "sqlmap".to_string();
    if use_proxy {
        args.insert(0, cmd_bin);
        cmd_bin = "proxychains".to_string();
    }

    let args_str: Vec<&str> = args.iter().map(|s| s.as_str()).collect();
    io.println(&format!("Executing: {} {}", cmd_bin, args_str.join(" ")));

    match executor.execute(&cmd_bin, &args_str) {
        Ok(s) => {
             if s.success() {
                 io.println(&format!("{}", "\n[+] SQLMap finished.".green()));
                 let _ = append_history(&HistoryEntry::new("Exploit-SQLMap", target, "Finished"));
             } else {
                 io.println(&format!("{}", "\n[!] SQLMap failed or stopped.".yellow()));
             }
        },
        Err(e) => io.println(&format!("{} {}", "[!] Failed to run sqlmap:".red(), e)),
    }
}

pub fn run_curl_exploit(target: &str, extra_args: Option<&str>, use_proxy: bool, executor: &dyn CommandExecutor, io: &dyn IoHandler) {
    io.println(&format!("\n{}", "--- Sophisticated Curl Exploit Tool ---".cyan().bold()));
    
    let mut method = "GET".to_string();
    let mut headers = Vec::new();
    let mut body: Option<String> = None;
    let mut cookies: Option<String> = None;
    let mut output_format = "Body Only".to_string();

    if extra_args.is_none() {
        // Step 1: Method
        io.print(&format!("{} [GET]: ", "HTTP Method".yellow()));
        io.flush();
        let m = io.read_line().trim().to_uppercase();
        if !m.is_empty() { method = m; }

        // Step 2: Custom Headers
        io.print(&format!("{} (e.g. 'Auth: token, X-Forwarded-For: 127.0.0.1'): ", "Headers".yellow()));
        io.flush();
        let h_in = io.read_line().trim().to_string();
        if !h_in.is_empty() {
            for h in h_in.split(',') {
                headers.push(h.trim().to_string());
            }
        }

        // Step 3: Cookies
        io.print(&format!("{} (e.g. 'session=abc; user=admin'): ", "Cookies".yellow()));
        io.flush();
        let c_in = io.read_line().trim().to_string();
        if !c_in.is_empty() { cookies = Some(c_in); }

        // Step 4: Body
        if method != "GET" && method != "HEAD" {
            io.print(&format!("{}: ", "Request Body".yellow()));
            io.flush();
            let b_in = io.read_line().trim().to_string();
            if !b_in.is_empty() { body = Some(b_in); }
        }

        // Step 5: Output Format
        io.println(&format!("\n{}", "Output Format:".blue()));
        io.println("[1] Body Only (Quiet)");
        io.println("[2] Full Response (Headers + Body)");
        io.println("[3] Headers Only");
        io.print("Select [1-3]: ");
        io.flush();
        match io.read_line().trim() {
            "2" => output_format = "Full".to_string(),
            "3" => output_format = "Headers".to_string(),
            _ => output_format = "Body Only".to_string(),
        }
    }

    // Build Curl Args
    let mut args = Vec::new();
    
    // Configurable parts
    args.push("-X".to_string());
    args.push(method);

    for h in headers {
        args.push("-H".to_string());
        args.push(h);
    }

    if let Some(c) = cookies {
        args.push("-b".to_string());
        args.push(c);
    }

    if let Some(b) = body {
        args.push("-d".to_string());
        args.push(b);
    }

    // Exploitation Defaults
    args.push("-L".to_string()); // Follow redirects
    args.push("-k".to_string()); // Insecure SSL
    args.push("-g".to_string()); // Disable globbing (crucial for payloads with {} [])
    
    match output_format.as_str() {
        "Full" => args.push("-i".to_string()),
        "Headers" => args.push("-I".to_string()),
        _ => args.push("-s".to_string()), // Silent progress meter, Body only
    }

    // Append extra args if any
    if let Some(extras) = extra_args {
        for arg in extras.split_whitespace() {
            args.push(arg.to_string());
        }
    }

    // Target is last
    args.push(target.to_string());

    let mut cmd_bin = "curl".to_string();
    if use_proxy {
        args.insert(0, cmd_bin);
        cmd_bin = "proxychains".to_string();
    }

    let args_str: Vec<&str> = args.iter().map(|s| s.as_str()).collect();
    
    io.println(&format!("\n{} Executing: {} {}\n", "[*]".blue().bold(), cmd_bin, args_str.join(" ")));

    match executor.execute(&cmd_bin, &args_str) {
        Ok(s) => {
            if !s.success() {
                io.println(&format!("{}", "[!] Curl returned non-zero exit code.".yellow()));
            }
        },
        Err(e) => io.println(&format!("{} {}", "[!] Failed to execute curl:".red(), e)),
    }
}