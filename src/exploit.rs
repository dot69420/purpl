use std::fs;
use colored::*;
use crate::executor::CommandExecutor;
use crate::io_handler::IoHandler;
use crate::history::{append_history, HistoryEntry};

pub fn run_exploitation_tool(target: &str, tool_name: Option<&str>, extra_args: Option<&str>, use_proxy: bool, executor: &dyn CommandExecutor, io: &dyn IoHandler) {
    io.println(&format!("\n{}", "--- Active Exploitation Module ---".red().bold()));

    let tool = if let Some(t) = tool_name {
        t.to_string()
    } else {
        io.println("Select Exploitation Tool:");
        io.println("[1] SQLMap (SQL Injection)");
        io.println("[2] Curl (Sophisticated Request Builder)");
        io.println("[0] Back");

        io.print("\nSelect tool: ");
        io.flush();
        let input = io.read_line();
        let choice = input.trim().parse::<usize>().unwrap_or(99);

        match choice {
            1 => "sqlmap".to_string(),
            2 => "curl".to_string(),
            0 => return,
            _ => {
                io.println(&format!("{}", "[!] Invalid selection.".red()));
                return;
            }
        }
    };

    match tool.as_str() {
        "sqlmap" => run_sqlmap(target, extra_args, use_proxy, executor, io),
        "curl" => run_curl_exploit(target, extra_args, use_proxy, executor, io),
        _ => io.println(&format!("{}", format!("[!] Unknown tool '{}'", tool).red()))
    }
}

pub fn run_sqlmap(target: &str, extra_args: Option<&str>, use_proxy: bool, executor: &dyn CommandExecutor, io: &dyn IoHandler) {
    if executor.execute_output("sqlmap", &["--version"]).is_err() {
        io.println(&format!("{}", "[-] 'sqlmap' not found. Please install it.".red()));
        return;
    }

    let safe_target = target.replace("://", "_").replace('/', "_").replace('?', "_");
    let output_dir = format!("scans/exploit/sqlmap/{}", safe_target);
    fs::create_dir_all(&output_dir).expect("Failed to create output dir");

    io.println(&format!("{}", format!("\n[+] Starting SQLMap on {}", target).green()));
    io.println(&format!("[+] Output directory: {}", output_dir));

    let mut args = vec![
        "-u".to_string(), target.to_string(),
        "--batch".to_string(),
        "--output-dir".to_string(), output_dir.clone(),
    ];

    if let Some(extras) = extra_args {
        for arg in extras.split_whitespace() {
            args.push(arg.to_string());
        }
    }

    let mut cmd_bin = "sqlmap".to_string();
    if use_proxy {
        args.insert(0, cmd_bin);
        cmd_bin = "proxychains".to_string();
    }

    let args_str: Vec<&str> = args.iter().map(|s| s.as_str()).collect();
    io.println(&format!("Executing: {} {}", cmd_bin, args_str.join(" ")));

    match executor.execute(&cmd_bin, &args_str) {
        Ok(s) => {
             if s.success() {
                 io.println(&format!("{}", "\n[+] SQLMap finished.".green()));
                 let _ = append_history(&HistoryEntry::new("Exploit-SQLMap", target, "Finished"));
             } else {
                 io.println(&format!("{}", "\n[!] SQLMap failed or stopped.".yellow()));
             }
        },
        Err(e) => io.println(&format!("{} {}", "[!] Failed to run sqlmap:".red(), e)),
    }
}

pub fn run_curl_exploit(target: &str, extra_args: Option<&str>, use_proxy: bool, executor: &dyn CommandExecutor, io: &dyn IoHandler) {
    io.println(&format!("\n{}", "--- Sophisticated Curl Exploit Tool ---".cyan().bold()));
    
    let mut method = "GET".to_string();
    let mut headers = Vec::new();
    let mut body: Option<String> = None;
    let mut cookies: Option<String> = None;
    let mut output_format = "Body Only".to_string();

    if extra_args.is_none() {
        // Step 1: Method
        io.print(&format!("{} [GET]: ", "HTTP Method".yellow()));
        io.flush();
        let m = io.read_line().trim().to_uppercase();
        if !m.is_empty() { method = m; }

        // Step 2: Custom Headers
        io.print(&format!("{} (e.g. 'Auth: token, X-Forwarded-For: 127.0.0.1'): ", "Headers".yellow()));
        io.flush();
        let h_in = io.read_line().trim().to_string();
        if !h_in.is_empty() {
            for h in h_in.split(',') {
                headers.push(h.trim().to_string());
            }
        }

        // Step 3: Cookies
        io.print(&format!("{} (e.g. 'session=abc; user=admin'): ", "Cookies".yellow()));
        io.flush();
        let c_in = io.read_line().trim().to_string();
        if !c_in.is_empty() { cookies = Some(c_in); }

        // Step 4: Body
        if method != "GET" && method != "HEAD" {
            io.print(&format!("{}: ", "Request Body".yellow()));
            io.flush();
            let b_in = io.read_line().trim().to_string();
            if !b_in.is_empty() { body = Some(b_in); }
        }

        // Step 5: Output Format
        io.println(&format!("\n{}", "Output Format:".blue()));
        io.println("[1] Body Only (Quiet)");
        io.println("[2] Full Response (Headers + Body)");
        io.println("[3] Headers Only");
        io.print("Select [1-3]: ");
        io.flush();
        match io.read_line().trim() {
            "2" => output_format = "Full".to_string(),
            "3" => output_format = "Headers".to_string(),
            _ => output_format = "Body Only".to_string(),
        }
    }

    // Build Curl Args
    let mut args = Vec::new();
    
    // Configurable parts
    args.push("-X".to_string());
    args.push(method);

    for h in headers {
        args.push("-H".to_string());
        args.push(h);
    }

    if let Some(c) = cookies {
        args.push("-b".to_string());
        args.push(c);
    }

    if let Some(b) = body {
        args.push("-d".to_string());
        args.push(b);
    }

    // Exploitation Defaults
    args.push("-L".to_string()); // Follow redirects
    args.push("-k".to_string()); // Insecure SSL
    args.push("-g".to_string()); // Disable globbing (crucial for payloads with {} [])
    
    match output_format.as_str() {
        "Full" => args.push("-i".to_string()),
        "Headers" => args.push("-I".to_string()),
        _ => args.push("-s".to_string()), // Silent progress meter, Body only
    }

    // Append extra args if any
    if let Some(extras) = extra_args {
        for arg in extras.split_whitespace() {
            args.push(arg.to_string());
        }
    }

    // Target is last
    args.push(target.to_string());

    let mut cmd_bin = "curl".to_string();
    if use_proxy {
        args.insert(0, cmd_bin);
        cmd_bin = "proxychains".to_string();
    }

    let args_str: Vec<&str> = args.iter().map(|s| s.as_str()).collect();
    
    io.println(&format!("\n{} Executing: {} {}\n", "[*]".blue().bold(), cmd_bin, args_str.join(" ")));

    match executor.execute(&cmd_bin, &args_str) {
        Ok(s) => {
            if !s.success() {
                io.println(&format!("{}", "[!] Curl returned non-zero exit code.".yellow()));
            }
        },
        Err(e) => io.println(&format!("{} {}", "[!] Failed to execute curl:".red(), e)),
    }
}