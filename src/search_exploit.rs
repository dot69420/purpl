use crate::executor::CommandExecutor;
use crate::io_handler::IoHandler;
use colored::*;
use roxmltree::Document;
use serde::Deserialize;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(Deserialize, Debug)]
pub struct SearchResult {
    #[serde(rename = "RESULTS_EXPLOIT")]
    pub results: Vec<ExploitItem>,
}

#[derive(Deserialize, Debug)]
pub struct ExploitItem {
    #[serde(rename = "Title")]
    pub title: String,
    #[serde(rename = "Path")]
    pub path: String,
    #[serde(rename = "Type")]
    pub kind: Option<String>,
}

pub struct Service {
    pub product: String,
    pub version: String,
    pub port: String,
}

#[derive(Debug, Clone)]
pub struct SearchExploitConfig {
    pub query: String,
    pub mode: SearchMode,
}

#[derive(Debug, Clone)]
pub enum SearchMode {
    DirectSearch,
    AutoCorrelate(PathBuf),
}

pub fn configure_searchsploit(
    target_input: &str,
    executor: &dyn CommandExecutor,
    io: &dyn IoHandler,
) -> Option<SearchExploitConfig> {
    if executor.execute_output("searchsploit", &["-h"]).is_err() {
        io.println(&format!(
            "{}",
            "[-] 'searchsploit' not found. Please install it.".red()
        ));
        return None;
    }

    let mut current_input = target_input.trim().to_string();

    if current_input.is_empty() {
        io.print(&format!(
            "{}",
            "\n[?] Enter Search Query or Target IP/XML: ".yellow()
        ));
        io.flush();
        let next = io.read_line().trim().to_string();
        if next.is_empty() {
            return None;
        }
        current_input = next;
    }

    let xml_path = resolve_xml_path(&current_input);

    if let Some(path) = xml_path {
        Some(SearchExploitConfig {
            query: current_input,
            mode: SearchMode::AutoCorrelate(path),
        })
    } else {
        Some(SearchExploitConfig {
            query: current_input,
            mode: SearchMode::DirectSearch,
        })
    }
}

pub fn execute_searchsploit(
    config: SearchExploitConfig,
    _use_proxy: bool,
    executor: &dyn CommandExecutor,
    io: &dyn IoHandler,
) {
    match config.mode {
        SearchMode::AutoCorrelate(xml_path) => {
            io.println(&format!(
                "{}",
                format!("[+] Parsing report: {}", xml_path.display()).blue()
            ));

            let services = extract_services(&xml_path);
            if services.is_empty() {
                io.println(&format!(
                    "{}",
                    "[-] No services with version information found in the report.".yellow()
                ));
            } else {
                io.println(&format!(
                    "{}",
                    format!(
                        "[+] Found {} services. Searching Exploit-DB...",
                        services.len()
                    )
                    .green()
                ));

                for svc in services {
                    let query_term = format!("{} {}", svc.product, svc.version);
                    if query_term.trim().len() < 3 {
                        continue;
                    }

                    io.println(&format!(
                        "\n{}: {} ({})",
                        "Querying".blue().bold(),
                        query_term.cyan(),
                        svc.port
                    ));

                    let mut args = vec![svc.product.as_str()];
                    if !svc.version.is_empty() {
                        args.push(svc.version.as_str());
                    }

                    perform_search(&args, executor, io);
                }
            }
        }
        SearchMode::DirectSearch => {
            io.println(&format!(
                "{}",
                format!("[*] Performing direct search for: '{}'", config.query).blue()
            ));
            let args: Vec<&str> = config.query.split_whitespace().collect();
            perform_search(&args, executor, io);
        }
    }
}

// Wrapper for loop/interactive mode
pub fn run_searchsploit(
    target_input: &str,
    use_proxy: bool,
    executor: &dyn CommandExecutor,
    io: &dyn IoHandler,
) {
    let mut current_target = target_input.to_string();
    loop {
        if let Some(config) = configure_searchsploit(&current_target, executor, io) {
            execute_searchsploit(config, use_proxy, executor, io);
        } else {
            break;
        }

        // Loop for "search again"
        io.print(&format!(
            "{}",
            "\n[?] Search again? (Enter new query, 'q' to quit): ".yellow()
        ));
        io.flush();
        let next = io.read_line().trim().to_string();
        if next.eq_ignore_ascii_case("q") || next.eq_ignore_ascii_case("exit") || next.is_empty() {
            break;
        }
        current_target = next;
    }
}

fn perform_search(search_terms: &[&str], executor: &dyn CommandExecutor, io: &dyn IoHandler) {
    let mut cmd_args = vec!["--json".to_string()];
    for term in search_terms {
        cmd_args.push(term.to_string());
    }
    let cmd_args_str: Vec<&str> = cmd_args.iter().map(|s| s.as_str()).collect();

    if let Ok(out) = executor.execute_output("searchsploit", &cmd_args_str) {
        let json_str = String::from_utf8_lossy(&out.stdout);
        if let Ok(res) = serde_json::from_str::<SearchResult>(&json_str) {
            if res.results.is_empty() {
                io.println(&format!("  {}", "No exploits found.".dimmed()));
            } else {
                // Table Header
                io.println(&format!(
                    "  {:<60} | {:<15} | {}",
                    "TITLE".bold().underline(),
                    "TYPE".bold().underline(),
                    "PATH".bold().underline()
                ));

                for exploit in res.results.iter().take(20) {
                    let title = if exploit.title.len() > 58 {
                        format!("{}...", &exploit.title[..55])
                    } else {
                        exploit.title.clone()
                    };

                    let kind = exploit.kind.as_deref().unwrap_or("?");
                    io.println(&format!(
                        "  {:<60} | {:<15} | {}",
                        title,
                        kind.green(),
                        exploit.path.dimmed()
                    ));
                }

                if res.results.len() > 20 {
                    io.println(
                        &format!("  ... and {} more results.", res.results.len() - 20).italic(),
                    );
                }
            }
        } else {
            io.println(&format!(
                "  {}",
                "No exploits found or invalid JSON.".dimmed()
            ));
        }
    } else {
        io.println(&format!(
            "  {}",
            "[-] Failed to execute searchsploit.".red()
        ));
    }
}

pub fn resolve_xml_path(input: &str) -> Option<PathBuf> {
    let path = Path::new(input);
    if path.is_file() && input.ends_with(".xml") {
        return Some(path.to_path_buf());
    }

    let safe_target = input.replace('/', "_");
    let nmap_dir = Path::new("scans").join("nmap").join(&safe_target);
    let legacy_dir = Path::new("scans").join(&safe_target);

    let scans_dir = if nmap_dir.exists() {
        nmap_dir
    } else if legacy_dir.exists() {
        legacy_dir
    } else {
        return None;
    };

    if let Ok(entries) = fs::read_dir(scans_dir) {
        let mut dirs: Vec<_> = entries.flatten().filter(|e| e.path().is_dir()).collect();
        dirs.sort_by_key(|e| e.file_name());
        for dir_entry in dirs.iter().rev() {
            if let Ok(files) = fs::read_dir(dir_entry.path()) {
                for f in files.flatten() {
                    if f.path().extension().map_or(false, |e| e == "xml") {
                        return Some(f.path());
                    }
                }
            }
        }
    }
    None
}

pub fn extract_services(path: &Path) -> Vec<Service> {
    let content = fs::read_to_string(path).unwrap_or_default();
    extract_services_from_content(&content)
}

pub fn extract_services_from_content(content: &str) -> Vec<Service> {
    let doc = match Document::parse(content) {
        Ok(d) => d,
        Err(_) => return Vec::new(),
    };

    let mut list = Vec::new();
    for port in doc.descendants().filter(|n| n.has_tag_name("port")) {
        if let Some(service) = port.children().find(|n| n.has_tag_name("service")) {
            let product = service.attribute("product").unwrap_or("").to_string();
            let version = service.attribute("version").unwrap_or("").to_string();
            let port_id = port.attribute("portid").unwrap_or("?").to_string();

            if !product.is_empty() {
                list.push(Service {
                    product,
                    version,
                    port: port_id,
                });
            }
        }
    }
    list
}

#[cfg(test)]
#[path = "search_exploit_tests.rs"]
mod tests;
