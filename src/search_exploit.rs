use std::path::{Path, PathBuf};
use std::fs;
use colored::*;
use roxmltree::Document;
use serde::Deserialize;
use crate::executor::CommandExecutor;
use crate::io_handler::IoHandler;

#[derive(Deserialize, Debug)]
pub struct SearchResult {
    #[serde(rename = "RESULTS_EXPLOIT")]
    pub results: Vec<ExploitItem>,
}

#[derive(Deserialize, Debug)]
pub struct ExploitItem {
    #[serde(rename = "Title")]
    pub title: String,
    #[serde(rename = "Path")]
    pub path: String,
    #[serde(rename = "Type")]
    pub kind: Option<String>,
}

pub struct Service {
    pub product: String,
    pub version: String,
    pub port: String,
}

pub fn run_searchsploit(target_input: &str, _use_proxy: bool, executor: &dyn CommandExecutor, io: &dyn IoHandler) {
    if executor.execute_output("searchsploit", &["--version"]).is_err() {
        io.println(&format!("{}", "[-] 'searchsploit' not found. Please install it.".red()));
        return;
    }

    let xml_path = resolve_xml_path(target_input);
    if xml_path.is_none() {
        io.println(&format!("{}", format!("[!] Could not find Nmap XML report for '{}'.", target_input).red()));
        return;
    }
    let xml_path = xml_path.unwrap();
    io.println(&format!("{}", format!("[+] Parsing report: {}", xml_path.display()).blue()));

    let services = extract_services(&xml_path);
    if services.is_empty() {
        io.println(&format!("{}", "[-] No services with version information found.".yellow()));
        return;
    }

    io.println(&format!("{}", format!("[+] Found {} services. Searching Exploit-DB...", services.len()).green()));

    for svc in services {
        let query_term = format!("{} {}", svc.product, svc.version);
        if query_term.trim().len() < 3 { continue; }

        io.println(&format!("\n{}: {} ({})", "Querying".blue().bold(), query_term.cyan(), svc.port));
        
        let (cmd_bin, cmd_args) = build_searchsploit_command("searchsploit", &svc.product, &svc.version);
        let cmd_args_str: Vec<&str> = cmd_args.iter().map(|s| s.as_str()).collect();

        if let Ok(out) = executor.execute_output(&cmd_bin, &cmd_args_str) {
            let json_str = String::from_utf8_lossy(&out.stdout);
            if let Ok(res) = serde_json::from_str::<SearchResult>(&json_str) {
                if res.results.is_empty() {
                    io.println(&format!("  {}", "No exploits found.".dimmed()));
                } else {
                    for exploit in res.results.iter().take(5) {
                        let kind = exploit.kind.as_deref().unwrap_or("?");
                        io.println(&format!("  [{}]. {} | {}", kind.green(), exploit.title, exploit.path.dimmed()));
                    }
                }
            } else {
                 io.println(&format!("  {}", "No exploits found.".dimmed()));
            }
        }
    }
}

pub fn resolve_xml_path(input: &str) -> Option<PathBuf> {
    let path = Path::new(input);
    if path.is_file() && input.ends_with(".xml") {
        return Some(path.to_path_buf());
    }

    let safe_target = input.replace('/', "_");
    let nmap_dir = Path::new("scans").join("nmap").join(&safe_target);
    let legacy_dir = Path::new("scans").join(&safe_target);

    let scans_dir = if nmap_dir.exists() { nmap_dir } else if legacy_dir.exists() { legacy_dir } else { return None; };

    if let Ok(entries) = fs::read_dir(scans_dir) {
        let mut dirs: Vec<_> = entries.flatten().filter(|e| e.path().is_dir()).collect();
        dirs.sort_by_key(|e| e.file_name());
        for dir_entry in dirs.iter().rev() {
            if let Ok(files) = fs::read_dir(dir_entry.path()) {
                for f in files.flatten() {
                    if f.path().extension().map_or(false, |e| e == "xml") {
                        return Some(f.path());
                    }
                }
            }
        }
    }
    None
}

pub fn extract_services(path: &Path) -> Vec<Service> {
    let content = fs::read_to_string(path).unwrap_or_default();
    extract_services_from_content(&content)
}

pub fn extract_services_from_content(content: &str) -> Vec<Service> {
    let doc = match Document::parse(content) {
        Ok(d) => d,
        Err(_) => return Vec::new(),
    };

    let mut list = Vec::new();
    for port in doc.descendants().filter(|n| n.has_tag_name("port")) {
         if let Some(service) = port.children().find(|n| n.has_tag_name("service")) {
             let product = service.attribute("product").unwrap_or("").to_string();
             let version = service.attribute("version").unwrap_or("").to_string();
             let port_id = port.attribute("portid").unwrap_or("?").to_string();

             if !product.is_empty() { 
                 list.push(Service { product, version, port: port_id });
             }
         }
    }
    list
}

pub fn build_searchsploit_command(base_cmd: &str, product: &str, version: &str) -> (String, Vec<String>) {
    let mut args = vec!["--json".to_string(), product.to_string()];
    if !version.is_empty() {
        args.push(version.to_string());
    }
    (base_cmd.to_string(), args)
}

#[cfg(test)]
#[path = "search_exploit_tests.rs"]
mod tests;
